#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1, lSensor, sensorLineFollower)
#pragma config(Sensor, in2, mSensor, sensorLineFollower)
#pragma config(Sensor, in3, rSensor, sensorLineFollower)
#pragma config(Sensor, in4, gyro, sensorGyro)
#pragma config(Sensor, in6, arm, sensorPotentiometer)
#pragma config(Sensor, dgtl1, rEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl3, lEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl6, touch, sensorTouch)
#pragma config(Sensor, dgtl8, sonar, sensorSONAR_cm)
#pragma config(Sensor, I2C_1, rightIME, sensorQuadEncoderOnI2CPort, , AutoAssign )
#pragma config(Sensor, I2C_2, leftIME, sensorQuadEncoderOnI2CPort, , AutoAssign )
#pragma config(Sensor, I2C_3, armIME, sensorQuadEncoderOnI2CPort, , AutoAssign )
#pragma config(Motor, port2, rMotor, tmotorVex393_MC29, openLoop, reversed, driveRight, encoderPort, I2C_1)
#pragma config(Motor, port3, lMotor, tmotorVex393_MC29, openLoop, driveLeft, encoderPort, I2C_2)
#pragma config(Motor, port6, armMotor, tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(DatalogSeries, 0, "LeftFollow", Sensors, Sensor, in1, 50)
#pragma config(DatalogSeries, 1, "MidFollow", Sensors, Sensor, in2, 50)
#pragma config(DatalogSeries, 2, "RightFollow", Sensors, Sensor, in3, 50)
//*!!Code automatically generated by 'ROBOTC' configuration wizard !!*//


int senseL = 0;
int senseR = 0;
int senseM = 0;
int sonarVal = 0;
int dist = 0;
int linesPassed = 0;
bool followLine = true;
bool gotBall = false;
bool foundSearchablePlace = false;

void forwards(int blocks){
	motor[lMotor]= 127;
	motor[rMotor]= 127;
	wait1Msec(blocks*200/5.3*10);
}
void backwards(int time){
	motor[lMotor]= -100;
	motor[rMotor]= -100;
	wait1Msec(time);
}

void left(){
	motor[lMotor]= -127;
	motor[rMotor]= 127;
	wait1Msec(620);
	motor[lMotor]= 0;
	motor[rMotor]= 0;
	wait1Msec(620);
}
void right(){
	motor[lMotor]= 127;
	motor[rMotor]= -127;
	wait1Msec(630);
	motor[lMotor]= 0;
	motor[rMotor]= 0;
	wait1Msec(630);
}

void trackLine(int rate){
	followLine = true;
	while(followLine){
		sonarVal = SensorValue[sonar];
		if(sonarVal<11){
			followLine = false;
			} else {
			senseL = SensorValue[lSensor];
			senseR = SensorValue[rSensor];
			if(senseL > senseR){
				motor[rMotor] = 100/rate;
				motor[lMotor] = 50/rate;
				} else if (senseR >senseL){
				motor[rMotor] = 50/rate;
				motor[lMotor] = 100/rate;
			}
		}
	}
}

void scoot(int duration){
	motor[lMotor]= 60;
	motor[rMotor]= 60;
	wait1Msec(duration);
}

void shake(){
	for(int n = 0; n<4;n++){
		motor[lMotor]= -30;
		motor[rMotor]= 50;
		wait1Msec(50);
		motor[lMotor]= 50;
		motor[rMotor]= -30;
		wait1Msec(50);
	}
}

void pickUpBall(){
	motor[lMotor]= 30;
	motor[rMotor]= 30;
	motor[armMotor] = -140;
	wait1Msec(500);
	motor[armMotor] = 0;
}

void freeze(){
	motor[lMotor]= 0;
	motor[rMotor]= 0;
	motor[armMotor] = 0;
	wait1Msec(500);
}

//This function is the opposite of the "pickUpBall" function, and will revert the arm back to its normal position downwards
void armDown(){
	//Slightly move forwards
	motor[lMotor]= 20;
	motor[rMotor]= 20;

	//Move arm down, and stop arm
	motor[armMotor] = 127;
	wait1Msec(600);
	motor[armMotor] = 0;
}

task main()
{
	forwards(1);

	//Searching for a ball

	//While we do not have a ball, continue the search
	while(!gotBall){

		//While we are not at a good search location, keep searching
		while(!foundSearchablePlace){

			//Update the middle colour sensor
			senseM = SensorValue[mSensor];

			//If the robot does not see a dark black line

			if(senseM<2000){
				//Keep moving forwards
				scoot(50);
				} else {
				//Otherwise you see a black line
				linesPassed+=1;		//Add the number of lines passed already
				scoot(400);				//Adjust to turn on top of line
				right();					//Turn right to face the ball

				//A position where a ball might exist should now be checked to see if there is a ball
				foundSearchablePlace = true;
			}

		}
		//Measure the distance of the first obstacle in front of you
		dist = SensorValue[sonar];

		//If the distance is bigger than where a pole holding a ball should be
		if(dist>44){
			left();							//Turn back to the original direction of travel
			forwards(1);				//Move forwards, leaving the past line

			//The robot is no longer at the place of interest
			foundSearchablePlace = false;

			} else {
			//There exists an obstacle, which is holding a ball
			backwards(500);			//Move backwards for more black line length in between the robot and ball (better line tracking)

			trackLine(2);			//Track and follow the black line to pick up the ball
			shake();						//Friction between pole and arm may cause algorithm to break, so we shake the arm in attempt to avoid friction problems
			pickUpBall();				//Pick up the ball by lifting the arm
			gotBall = true;			//Finally, we have found our ball
		}
	}



	backwards(1000);				//Having a ball, back up
	left();									//Face the next destination by turning left
	forwards(2);						//Move forwards to evade current black line in case of counting mistakes

	bool checkpoint = false;
	while(!checkpoint){
		if(linesPassed==4){
			checkpoint = true;
			} else {
			senseM = SensorValue[mSensor];
			if(senseM>1100){
				linesPassed+=1;
				forwards(1);
			}
		}

		scoot(100);
	}

	right();
	forwards(2);
	armDown();
	freeze();
	pickUpBall();
	pickUpBall();
	backwards(1500);

	left();
	dist = 100;
	while(dist>40){
		dist = SensorValue[sonar];
		forwards(1);
	}
	backwards(300);
	right();
	trackLine(1);
	right();

	forwards(20);
	left();
	forwards(10);
	right();
	forwards(8);
	left();
	forwards(8);
	left();
	forwards(10);
}
