#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1, lSensor, sensorLineFollower)
#pragma config(Sensor, in2, mSensor, sensorLineFollower)
#pragma config(Sensor, in3, rSensor, sensorLineFollower)
#pragma config(Sensor, in4, gyro, sensorGyro)
#pragma config(Sensor, in6, arm, sensorPotentiometer)
#pragma config(Sensor, dgtl1, rEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl3, lEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl6, touch, sensorTouch)
#pragma config(Sensor, dgtl8, sonar, sensorSONAR_cm)
#pragma config(Sensor, I2C_1, rightIME, sensorQuadEncoderOnI2CPort, , AutoAssign )
#pragma config(Sensor, I2C_2, leftIME, sensorQuadEncoderOnI2CPort, , AutoAssign )
#pragma config(Sensor, I2C_3, armIME, sensorQuadEncoderOnI2CPort, , AutoAssign )
#pragma config(Motor, port2, rMotor, tmotorVex393_MC29, openLoop, reversed, driveRight, encoderPort, I2C_1)
#pragma config(Motor, port3, lMotor, tmotorVex393_MC29, openLoop, driveLeft, encoderPort, I2C_2)
#pragma config(Motor, port6, armMotor, tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(DatalogSeries, 0, "LeftFollow", Sensors, Sensor, in1, 50)
#pragma config(DatalogSeries, 1, "MidFollow", Sensors, Sensor, in2, 50)
#pragma config(DatalogSeries, 2, "RightFollow", Sensors, Sensor, in3, 50)
//*!!Code automatically generated by 'ROBOTC' configuration wizard !!*//


//Global variable for the sonar's return value of the distance of obstacles in front of the robot
int senseVal = 0;

//This function will make the robot move straight forwards "int blocks" number of blocks on the grid of a table
void forwards(int blocks){
	motor[lMotor]= 127;
	motor[rMotor]= 127;
	wait1Msec(blocks*200/5.3*10);
}

//This function will move the arm up and out of the way
void armMove(){
	motor[armMotor] = -127;
	wait1Msec(100);
}

//This function will allow the robot to rotate counter clockwise
void left(){
	motor[lMotor]= -127;
	motor[rMotor]= 127;
	wait1Msec(100);
}

task main()
{
	//Get rid of arm
	armMove();

	//Initialize a boolean delcaring that the obstacle has not yet been found
	bool found = false;

	//While the object is not found, keep searching
	while(!found){

		//Check the sonar for an object in front of it
		senseVal = SensorValue[sonar];

		//If an obstacle is picked up by the sonar, then end the search
		if(senseVal!=-1){
			found = true;
		} else {
		//Otherwise, keep rotating to the left, scanning the environment
			left();
		}
	}
	//After the object is found, rotate to the left a bit more to center the robot's heading towards the obstacle
	left();

	//Move forwards 3 units towards the obstacle
	forwards(3);
}
